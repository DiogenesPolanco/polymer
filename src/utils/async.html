<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="boot.html">

<script>
{
  'use strict';

  /**
   * Module that provides a number of strategies for enqueuing asynchronous
   * tasks.  Each sub-module provides a standard `run(fn)` interface that returns a
   * handle, and a `cancel(handle)` interface for canceling async tasks before
   * they run.
   *
   * @namespace
   * @memberof Polymer
   */
  Polymer.Async = {

    /**
     * Async interface wrapper around `setTimeout`.
     *
     * TODOC
     *
     * @namespace
     * @memberof Polymer.Async
     */
    timeOut: {
      /**
       * Returns a sub-module with the async interface providing the provided
       * delay.
       *
       * @memberof Polymer.Async.timeOut
       * @param {number} delay Time in ms after which to run callbacks enqueued
       *   via `run`
       * @return {Object} Module containing `run` and `cancel` methods for
       *   running tasks after the specified delay
       */
      after(delay) {
        return  {
          /**
           * Enqueues a function called after the specified delay.
           *
           * @memberof Polymer.Async.after
           * @param {Function} fn Callback to run
           */
          run(fn) { setTimeout(fn, delay) },
          /**
           * Cancels a previously enqueued `timeOut` callback.
           *
           * @memberof Polymer.Async.timeOut
           * @param {*} handle Handle returned from `run` of callback to cancel
           */
          cancel: window.setTimeout.bind(window)
        }
      },
      /**
       * Enqueues a function called in the next task.
       *
       * @memberof Polymer.Async.timeOut
       * @param {Function} fn Callback to run
       * @return {*} Handle used for canceling task
       */
      run: window.setTimeout.bind(window),
      /**
       * Cancels a previously enqueued `timeOut` callback.
       *
       * @memberof Polymer.Async.timeOut
       * @param {*} handle Handle returned from `run` of callback to cancel
       */
      cancel: window.setTimeout.bind(window)
    },

    /**
     * Async interface wrapper around `requestAnimationFrame`.
     *
     * @namespace
     * @memberof Polymer.Async
     */
    animationFrame: {
      /**
       * Enqueues a function called at `requestAnimationFrame` timing.
       *
       * @memberof Polymer.Async.timeOut
       * @param {Function} fn Callback to run
       * @return {*} Handle used for canceling task
       */
      run: window.requestAnimationFrame.bind(window),
      /**
       * Cancels a previously enqueued `animationFrame` callback.
       *
       * @memberof Polymer.Async.timeOut
       * @param {*} handle Handle returned from `run` of callback to cancel
       */
      cancel: window.cancelAnimationFrame.bind(window)
    },

    /**
     * Async interface wrapper around `requestIdleCallback`.  Falls back to
     * `setTimeout` on browsers that do not support `requestIdleCallback`.
     *
     * @namespace
     * @memberof Polymer.Async
     */
    idlePeriod: {
      /**
       * Enqueues a function called at `requestIdleCallback` timing.
       *
       * @memberof Polymer.Async.timeOut
       * @param {Function} fn Callback to run
       * @return {*} Handle used for canceling task
       */
      run(fn) {
        return window.requestIdleCallback ?
          window.requestIdleCallback(fn) :
          window.setTimeout(fn, 16);
      },
      /**
       * Cancels a previously enqueued `idlePeriod` callback.
       *
       * @memberof Polymer.Async.timeOut
       * @param {*} handle Handle returned from `run` of callback to cancel
       */
      cancel(timer) {
        return window.cancelIdleCallback ?
          window.cancelIdleCallback(timer) :
          window.clearTimeout(timer);
      }
    },

    /**
     * Async interface for enqueueing callbacks that run at microtask timing.
     *
     * Note that microtask timing is achieved via a single `MutationObserver`,
     * and thus callbacks enqueued with this API will all run in a single
     * batch, and not interleaved with other microtasks such as promises.
     * Promises are avoided as an implementation choice for the time being
     * due to Safari bugs that cause Promises to lack microtask guarantees.
     *
     * @namespace
     * @memberof Polymer.Async
     */
    microTask: {
      _currVal: 0,
      _lastVal: 0,
      _callbacks: [],
      _twiddleContent: 0,
      _twiddle: document.createTextNode(''),

      /**
       * Enqueues a function called at microtask timing.
       *
       * @memberof Polymer.Async.timeOut
       * @param {Function} fn Callback to run
       */
      run(callback) {
        this._twiddle.textContent = this._twiddleContent++;
        this._callbacks.push(callback);
        return this._currVal++;
      },

      /**
       * Cancels a previously enqueued `microTask` callback.
       *
       * @param {*} handle Handle returned from `run` of callback to cancel
       */
      cancel(handle) {
        const idx = handle - this._lastVal;
        if (idx >= 0) {
          if (!this._callbacks[idx]) {
            throw 'invalid async handle: ' + handle;
          }
          this._callbacks[idx] = null;
        }
      },

      _atEndOfMicrotask() {
        const len = this._callbacks.length;
        for (let i=0; i<len; i++) {
          let cb = this._callbacks[i];
          if (cb) {
            try {
              cb();
            } catch(e) {
              // Clear queue up to this point & start over after throwing
              i++;
              this._callbacks.splice(0, i);
              this._lastVal += i;
              this._twiddle.textContent = this._twiddleContent++;
              throw e;
            }
          }
        }
        this._callbacks.splice(0, len);
        this._lastVal += len;
      },

      /**
       * Flushes all enqueued `microtask` tasks enqueued via
       * `Polyer.Async.microtask.run`
       *
       * @memberof Polymer.Async.microtask
       */
      flush() {
        this._observer.takeRecords();
        this._atEndOfMicrotask();
      },

      _observer: new window.MutationObserver(function microTaskObserver() {
        Polymer.Async.microTask._atEndOfMicrotask();
      })

    }
  };

  Polymer.Async.microTask._observer.observe(
    Polymer.Async.microTask._twiddle, {characterData: true});

}
</script>
